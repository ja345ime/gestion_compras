Descripción general: Esta aplicación es un Sistema de Requisiciones de Compras desarrollado en Flask. Permite a los usuarios crear requisiciones de materiales/servicios, obtener aprobaciones por área (Jefe de Departamento, Almacén, Compras) y envía notificaciones por correo electrónico en cada paso del flujo. El sistema maneja distintos roles de usuario (Solicitante, JefeDepartamento, Almacen, Compras, Admin, Superadmin), cada uno con permisos definidos para las diferentes etapas del proceso. Arquitectura Flask: El código está organizado como un paquete Flask llamado app. En app/__init__.py se configura la aplicación mediante create_app(): se carga la configuración desde config.py, se inicializan extensiones (base de datos SQLAlchemy, manejo de sesiones de usuario con Flask-Login, protección CSRF, etc.) y se registra el Blueprint principal de la aplicación (main). Si existen migraciones pendientes (por ejemplo añadir campos a modelos), se aplican automáticamente al iniciar. Configuración (app/config.py): Contiene constantes y ajustes globales. Define, entre otras cosas, los estados de las requisiciones en el flujo (p.ej. “Pendiente Revisión Almacén”, “Aprobada por Almacén”, “En Compra”, “Recibida Completa”, “Rechazada”, etc.), agrupados en listas para estados activos e históricos. También configura parámetros como la duración de sesión (DURACION_SESION), límites de tiempo para editar requisiciones ya creadas, credenciales para servicios externos (API de correo Brevo/Sendinblue), y otras opciones necesarias para el funcionamiento. Modelos de datos (app/models.py): Define las clases ORM utilizando SQLAlchemy. Modelos principales:
• Usuario: usuarios del sistema (campos: nombre, email, departamento, rol, contraseña hasheada, etc.).
• Rol: roles de usuario (Solicitante, JefeDepartamento, Almacen, Compras, Admin, Superadmin), con permisos predefinidos.
• Departamento: áreas de la empresa (Compras, Almacén, Producción, etc.) a las que pertenecen los usuarios y las requisiciones.
• Requisicion: solicitud de compra generada por un usuario, con campos como título, descripción, departamento solicitante, prioridad, estado actual, fechas de creación y actualización, y relación a uno o múltiples DetalleRequisicion.
• DetalleRequisicion: ítems individuales dentro de una requisición (producto/servicio requerido, cantidad, unidad, etc.).
• ProductoCatalogo: catálogo de productos disponibles; cada vez que se agrega un producto nuevo en una requisición, se registra aquí para futuras selecciones (evitando duplicados de nombre).
• AuditoriaAcciones: registro de acciones importantes en el sistema (creación/modificación de usuarios, cambios de estado en requisiciones, eliminaciones, etc., con fecha, usuario que realizó la acción y descripción).
(Estos modelos se relacionan entre sí: por ej., Requisicion tiene un campo foreign key al solicitante (Usuario) y al departamento, y contiene una lista de DetalleRequisicion asociados. Un DetalleRequisicion referencia un ProductoCatalogo. Un Usuario pertenece a un Departamento y tiene un Rol, etc.) Formularios (app/forms.py): Contiene los formularios web con WTForms para la interacción de usuarios. Algunos formularios destacados:
• LoginForm (inicio de sesión),
• RequisicionForm (creación/edición de requisiciones, incluye campos dinámicos para múltiples detalles de requisición),
• CambiarEstadoForm (para que Almacén o Compras cambien el estado de una requisición existente, añadiendo comentarios si es necesario),
• UserForm y EditUserForm (creación y edición de usuarios, con selección de roles y departamento),
• Formularios de confirmación (por ejemplo, para confirmar la eliminación de una requisición o de un usuario).
Estos formularios implementan validaciones (por ejemplo, campos obligatorios, formatos de email válidos, evitar datos duplicados como un mismo nombre de usuario, etc.) para garantizar la integridad de los datos enviados desde el frontend. Rutas y vistas (app/routes.py y blueprints): La aplicación utiliza un Blueprint principal definido en app/routes.py (referenciado como main). Aquí se definen las rutas/endpoints accesibles vía HTTP. Todas las rutas importantes requieren autenticación (@login_required), y algunas exigen roles específicos usando decoradores (por ejemplo, solo un Admin puede acceder a rutas de gestión de usuarios, usando @admin_required). Resumen de las rutas principales:
• Auth: GET /login (muestra formulario de login), POST /login (procesa credenciales), GET /logout.
• Requisiciones (Solicitante): GET /requisiciones (lista requisiciones del usuario, con paginación y filtros), GET /requisiciones/nueva & POST /requisiciones/nueva (crear nueva requisición), GET /requisiciones/<id> (ver detalle de una requisición específica), GET/POST /requisiciones/<id>/editar (editar una requisición existente), POST /requisiciones/<id>/eliminar (eliminar requisición, con confirmación). El acceso a editar/eliminar está restringido (solo antes de cierto tiempo y si el estado lo permite, además de pertenecer al solicitante).
• Aprobación por Jefe de Departamento: (pendiente de implementar completamente) Si el flujo lo requiere, habría rutas para que un JefeDept apruebe o rechace requisiciones de su departamento.
• Revisión de Almacén: rutas para que usuarios con rol Almacen vean requisiciones pendientes de su revisión (GET /almacen/pendientes por ejemplo) y aprueben/rechacen las solicitudes. Al aprobar, la requisición pasa a estado “Pendiente de Cotizar” y queda en manos de Compras.
• Gestión de Compras: rutas para rol Compras como GET /compras/pendientes (ver requisiciones aprobadas por Almacén pendientes de cotizar), opción de añadir cotizaciones a una requisición (podría ser GET/POST /requisiciones/<id>/cotizaciones/nueva), seleccionar una cotización ganadora y marcar la requisición como Aprobada por Compras (lo que generaría una Orden de Compra, feature en desarrollo), o rechazarla si ninguna cotización es satisfactoria.
• Usuarios y Admin: GET /admin/usuarios (lista usuarios), GET/POST /admin/usuarios/nuevo, GET/POST /admin/usuarios/<id>/editar, POST /admin/usuarios/<id>/eliminar. Solo accesibles con rol Admin. Similar manejo para departamentos y otros catálogos si existen.
• Otras: Rutas para descargar PDF de una requisición (GET /requisiciones/<id>/pdf), ver dashboard o inicio (pudiendo mostrar estadísticas básicas por rol), manejo de errores 404/500 con páginas personalizadas, etc.
(Nota: algunas rutas pueden estar divididas en Blueprints adicionales. Por ejemplo, si existe app/requisiciones/routes.py como blueprint específico para requisiciones, esas rutas estarían registradas allí. En esta descripción asumimos un blueprint principal; se debe ajustar si en el código real hay múltiples blueprints.) Funciones utilitarias (app/utils.py): Módulo de soporte con funciones y decoradores que son utilizadas por las rutas y otros componentes:
• Decoradores de autorización: admin_required, superadmin_required restringen el acceso según el rol del usuario autenticado.
• Funciones de inicialización/migración: ensure_session_token_column, ensure_ultimo_login_column modifican la base de datos al vuelo para añadir columnas que falten en la tabla de usuarios (esto ayuda a evitar errores si el modelo cambia y la migración no se ejecutó manualmente).
• Registro de acciones: registrar_accion(usuario, descripcion) guarda un registro en AuditoriaAcciones para cada evento importante (creación, edición o eliminación de entidades, cambios de estado en requisiciones, etc., con detalle de quién y qué hizo). registrar_intento(usuario, exito) guarda intentos de login en la tabla IntentoLoginFallido para controlar bloqueos de seguridad.
• Seguridad en login: exceso_intentos(ip_ouser) comprueba si ha habido ≥5 intentos fallidos de login recientes desde una IP o para un usuario, y de ser así bloquea temporalmente nuevos intentos (protección anti-fuerza bruta).
• Carga inicial de datos: crear_datos_iniciales() crea registros base (departamentos, roles) la primera vez que corre la app si no existen, e incluso crea un usuario Admin por defecto (usando la contraseña definida en variable de entorno ADMIN_PASSWORD). También define la lista predefinida de departamentos (“Administración”, “Compras”, “Almacén”, etc.) y roles con sus descripciones (Solicitante, JefeDepartamento, Almacén, Compras, Producción, Admin, Superadmin).
• Email y notificaciones: funciones para envío de correos mediante la API de Brevo: enviar_correo(destinatario, asunto, mensaje_html) envía un email individual, y enviar_correos_por_rol(rol, asunto, mensaje_html) obtiene todos los usuarios activos de cierto rol y les envía un correo (utiliza internamente la anterior). Estas funciones usan claves API y remitente configurados en variables de entorno, y construyen el cuerpo del correo usando plantillas HTML definidas para cada tipo de notificación (por ejemplo, notificar al solicitante cuando su requisición cambia de estado, notificar a Almacén de nueva requisición pendiente, notificar a Compras cuando una requisición queda pendiente de cotizar, etc.).
• Gestión de requisiciones: cambiar_estado_requisicion(requisicion, nuevo_estado, comentarios) actualiza el estado de una requisición, registra la acción en auditoría y dispara las notificaciones por correo correspondientes según el nuevo estado. Por ejemplo, si nuevo_estado es Pendiente Revisión Almacén, envía correo al rol Almacén; si es Aprobada por Almacén, notifica al rol Compras; si es Rechazada, notifica al Solicitante con el motivo, etc., siguiendo el flujo definido.
• Generación de PDFs y limpieza: generar_pdf_requisicion(requisicion) crea un PDF con los detalles de la requisición (usando una plantilla simple que incluye el logo y la lista de ítems), utilizado para guardar un respaldo. subir_pdf_a_drive(path_pdf) (funcionalidad opcional) sube ese PDF a Google Drive corporativo mediante la API (requiere credenciales configuradas). limpiar_requisiciones_viejas(dias) busca requisiciones en estados finales (como Cerrada, Rechazada, Recibida Completa) cuya antigüedad supera N días, les genera PDF si no lo tenían y las elimina de la base de datos (esto mantiene la tabla de requisiciones con un tamaño manejable a largo plazo, archivando las antiguas en PDF). Pruebas automatizadas: El proyecto incluye un conjunto de tests (en la carpeta tests/) desarrollados con Pytest. Estas pruebas cubren las funcionalidades clave: creación y flujo completo de una requisición a través de sus estados (incluyendo aprobaciones por Almacén/Compras), verificación de permisos de acceso según rol, comprobación de que las notificaciones se envían (simulando las llamadas de correo), tests de los modelos (por ej. que no se permitan duplicados donde no debe, o que crear_datos_iniciales funcione idempotentemente), etc. Antes de desplegar cambios, todas las pruebas deben pasar exitosamente. La herramienta de automatización Codex ejecutará pytest después de aplicar cambios; si alguna prueba falla, significará que el cambio introdujo un error que deberá ser corregido. Por lo tanto, cualquier modificación al código debe preservar (o actualizar junto con) el comportamiento esperado por los tests. Resumen del objetivo: Con esta arquitectura, la aplicación busca digitalizar y agilizar el proceso interno de compras. Codex (el modelo de IA) tiene permitido modificar cualquier parte del código fuente cuando se le indica en el prompt del usuario, siempre y cuando dichas modificaciones mejoren o amplíen el sistema sin romper la lógica existente ni los casos de uso esperados. Se espera que el modelo respete esta estructura modular (no introducir malas prácticas, mantener la consistencia con el estilo del código existente en español, y seguir las convenciones establecidas). Ante nuevas instrucciones (prompts), Codex determinará qué archivos son relevantes (por ejemplo, modelos, rutas, forms, etc.) y los actualizará o creará nuevos archivos según sea necesario para cumplir la funcionalidad solicitada, manteniendo el proyecto funcional y todas las pruebas en verde. Este contexto técnico debe guiar al modelo en ese proceso, sirviendo como referencia de cómo está construido el sistema y cuáles son las piezas con las que puede trabajar.
